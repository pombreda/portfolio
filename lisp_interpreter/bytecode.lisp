; bytecode.lisp
; Routines for constructing and printing Vitamin bytecode

(in-package "VITALISP")

(defparameter *instruction-table*
  '((nop)
    (cptemp dest source)
    (cpconst dest (constant constant))
    (skip (literal distance))
    (skipunless pred (literal distance))
    (call dest (reference fun) (literal arg-count) (variadic arg-count arg))
    (tailcall (reference fun) (literal arg-count) (variadic arg-count arg))
    (return (literal ret-count) (variadic ret-count result))
    (mvcall (literal ret-count) (variadic ret-count dest)
     (literal arg-count) (variadic arg-count arg))
    (apply dest (literal arg-count) (variadic arg))
    (funcall dest (literla arg-count) (variadic arg))
    (box box source)
    (boxref dest box)
    (boxset box new-value)
    (closure dest
     (reference fun) (literal clos-count) (variadic clos-count reg))
    (closureref dest closure (literal index))
    (eq dest source1 source2)
    (equal dest source1 source2)
    (numadd dest source1 source2)
    (numsub dest source1 source2)
    (nummul dest source1 source2)
    (numdiv dest source1 source2)
    (numcmpl dest source1 source2)
    (numcmple dest source1 source2)
    (numcmpg dest source1 source2)
    (numcmpge dest source1 source2)
    (numcmpe dest source1 source2)
    (numcmpne dest source1 source2)
    (numpow dest base expt)
    (nummod dest num denom)
    (print dest reg)
    (not dest reg)))

(defclass bytecode-element ()
  ((name :initarg :name :reader be-name)))

(defclass bytecode-procedure (bytecode-element)
  ((label-count :initform -1 :accessor bp-label-count)
   (temp-count :initform -1 :accessor bp-temp-count)
   (code-vec :initform (new-stretchy-vector) :reader bp-code-vec)
   (const-vec :initform (new-stretchy-vector) :reader bp-const-vec)
   (ref-vec :initform (new-stretchy-vector) :reader bp-ref-vec)))

(defclass bytecode-builder ()
  ((uniq-count :initform -1 :accessor bb-uniq-count)
   (elts :initform (new-stretchy-vector) :reader bb-elts)
   (elt-stack :initform nil :accessor bb-elt-stack)
   (curr-elt :initform nil :accessor bb-curr-elt)))

(defun push-element (bb type name)
  (let ((elt (make-instance type :name name)))
    (setf (bb-curr-elt bb) elt)
    (push elt (bb-elt-stack bb))
    elt))

(defun pop-element (bb)
  (let ((elt (pop (bb-elt-stack bb))))
    (setf (bb-curr-elt bb) (first (bb-elt-stack bb)))
    (vector-push-extend elt (bb-elts bb))
    elt))

(defun generate-label (bb)
  (let ((nr (incf (bp-label-count (bb-curr-elt bb)))))
    (intern (concatenate 'string ".l" (format nil "~A" nr)))))

(defun generate-temporary (bb)
  (incf (bp-temp-count (bb-curr-elt bb))))

(defun generate-constant (bb value)
  (let ((cv (bp-const-vec (bb-curr-elt bb))))
    (or (position value cv :test #'eql)
	(progn (vector-push-extend value cv)
	       (- (length cv) 1)))))

(defun generate-reference (bb name)
  (let ((rv (bp-ref-vec (bb-curr-elt bb))))
    (or (position name rv :test #'equal)
	(progn (vector-push-extend name rv)
	       (- (length rv) 1)))))

(defun generate-unique-name (bb str)
  (concatenate 'string str (format nil "~A" (incf (bb-uniq-count bb)))))

(defun decorate-name (str ns)
  (let* ((sfx (ecase ns
		(:variable "_v")
		(:function "_f"))))
    (concatenate 'string str sfx)))

(defun emit-instruction (bb ins &rest args)
  (let ((cv (bp-code-vec (bb-curr-elt bb)))
	(opc (position ins *instruction-table* :key #'first)))
    (unless opc (error (format nil "Invalid instruction ~A" ins)))
    (vector-push-extend opc cv)
    (map nil #'(lambda (arg) (vector-push-extend arg cv)) args)))

(defun emit-operands (bb args)
  (let ((cv (bp-code-vec (bb-curr-elt bb))))
    (map nil #'(lambda (arg) (vector-push-extend arg cv)) args)))

(defun emit-label (bb label)
  (vector-push-extend label (bp-code-vec (bb-curr-elt bb))))

(defun emit-forward-jump (bb label)
  (emit-label bb label))

(defun print-bytecode-procedure (proc)
  (format t "Procedure: ~A~%" (be-name proc))
  (format t "Code vector: ~A~%" (bp-code-vec proc))
  (labels ((print-argument (spec arg)
	     (if (atom spec)
		 (format t "<~A> " arg)
		 (ecase (first spec) 
		   (literal (format t "(~A) " arg))
		   (constant (format t "[~A] " (aref (bp-const-vec proc) arg)))
		   (reference (format t "{~A} " (aref (bp-ref-vec proc) arg)))
		   (variadic (format t "<~A> " arg)))))
	   (print-arguments (specs arg-idx arg-map)
	     (if (not specs) 
		 arg-idx
		 (let* ((spec (first specs))
		       (arg (and (< arg-idx (length (bp-code-vec proc)))
				 (aref (bp-code-vec proc) arg-idx)))
		       (count (if (and (consp spec) (eq (first spec) 'variadic))
				  (gethash (second spec) arg-map)
				  1)))
		   (when (and (consp spec) (eq (first spec) 'literal))
		     (setf (gethash (second spec) arg-map) arg))
		   (map nil
			#'(lambda (arg)
			    (print-argument spec arg))
			(subseq (bp-code-vec proc) arg-idx (+ arg-idx count)))
		   (print-arguments (rest specs) (+ arg-idx count) arg-map))))
	   (print-instruction (idx)
	     (when (< idx (length (bp-code-vec proc)))
	       (let ((elt (aref (bp-code-vec proc) idx)))
		 (if (symbolp elt)
		     (progn
		       (format t "~A:~%" elt)
		       (print-instruction (+ idx 1)))
		     (let* ((opc elt)
			    (fmt (nth opc *instruction-table*))
			    (mnem (first fmt)))
		       (format t "~A " mnem)
		       (let ((new-idx (print-arguments (rest fmt) 
						       (+ idx 1)
						       (make-hash-table))))
			 (format t "~%")
			 (print-instruction new-idx))))))))
	   (print-instruction 0)
	   (format t "~%")))

(defun print-bytecode (elts)
  (map nil #'print-bytecode-procedure elts))
